\section{Desarrollo}

  \subsection{Consideraciones generales}
    Las imagenes que utilizaremos como entrada y salida de los algoritmos a implementar serán matrices de píxeles. Cada uno de estos píxeles estará representado por cuatro enteros sin signo de 8 bits de profundidad (es decir, en el rango [0, 256)), que representarán, respectivamente, los valores de los colores azul (\textsf{b}), verde (\textsf{g}) y rojo (\textsf{r}), y la transparencia (\textsf{a}).

    Usaremos la notación $I_{x,y}$ para referirnos al píxel ubicado en la fila $x$ y la columna $y$ de la imagen $I$, y la notación $I_{x,y}^k$ para hacer referencia al valor de la componente $k$ de este píxel, donde $k \in \lbrace \mathsf{b, g, r, a} \rbrace$.
  
  \subsection{Diferencia de imágenes}
    Este filtro recibe dos imágenes como entrada y devuelve como salida una tercera imagen que muestra, en cada píxel, la diferencia entre los píxeles correspondientes de las imágenes de entrada, ignorando la componente \textsf{a}. Más especificamente, si $I_1$ e $I_2$ son las imágenes de entrada y $O$ es la imagen de salida, entonces:

    \[ O_{x,y}^k = \begin{cases}
      \displaystyle \max_{k \in \lbrace \mathsf{b, g, r} \rbrace} \left( \left\vert {I_1}_{x,y}^k - {I_2}_{x,y}^k \right\vert \right)
        & \text{si } k \in \lbrace \mathsf{b, g, r} \rbrace \\
      255
        & \text{si } k = \mathsf{a}
    \end{cases} \]

    \subsubsection{Implementación en lenguaje C}

    \subsubsection{Implementación en lenguaje ensamblador}
      Dado que los registros \texttt{XMM} son de 16 bytes, se los puede utilizar para procesar 4 píxeles de las imágenes en paralelo, reduciendo la cantidad de iteraciones del algoritmo y, particularmente, de accesos a memoria necesarios para completar el algoritmo.

      Nuestra implementación del filtro consiste principalmente de un ciclo que itera sobre la imagen. Al comienzo de cada ejecución, se copian 4 píxeles de $I_1$ al registro \texttt{XMM0}, y los correspondientes 4 píxeles de $I_2$ a \texttt{XMM1}.

      \raisebox{2.5mm}{\texttt{XMM0:} } \begin{TAB}(b,1cm,.8cm)[5pt]{|c|c|c|c|c|c|c|}{|c|}
        $A_4^{\mathsf{b}}$ &
        $A_4^{\mathsf{g}}$ &
        $A_4^{\mathsf{r}}$ &
        $A_4^{\mathsf{a}}$ &
        $A_3^{\mathsf{b}}$ &
        $\cdots$ &
        $A_1^{\mathsf{a}}$ \\
      \end{TAB}

      \raisebox{2.5mm}{\texttt{XMM1:} } \begin{TAB}(b,1cm,.8cm)[5pt]{|c|c|c|c|c|c|c|}{|c|}
        $B_4^{\mathsf{b}}$ &
        $B_4^{\mathsf{g}}$ &
        $B_4^{\mathsf{r}}$ &
        $B_4^{\mathsf{a}}$ &
        $B_3^{\mathsf{b}}$ &
        $\cdots$ &
        $B_1^{\mathsf{a}}$ \\
      \end{TAB}

      El paso siguiente es, para cada una de las componentes de estos píxeles, calcular el valor absoluto de la diferencia entre ambas imágenes. Para realizar esto, realizamos las dos restas, es decir, $\mathtt{XMM0} - \mathtt{XMM1}$ y $\mathtt{XMM1} - \mathtt{XMM0}$. En las posiciones donde el valor contenido en \texttt{XMM0} sea mayor que el de \texttt{XMM1}, será válido el resultado de la primera operación, mientras que en las demás posiciones deberemos quedarnos con el segundo resultado.

      Para seleccionar con cuál de los dos resultados quedarnos, utilizamos una máscara que obtenemos comparando los valores de \texttt{XMM0} y \texttt{XMM1}. Aquí nos encontramos con un problema, ya que debemos comparar enteros sin signo, y \acr{SSE} no brinda instrucciones para hacer esto. Es por eso que recurrimos a desempaquetar los números y considerarlos como enteros con signo de dos bytes, que sí podemos comparar.

      En primer lugar, usando la instrucción \texttt{PUNPCKLBW}, desempaquetamos las partes bajas de \texttt{XMM0} y \texttt{XMM1} en los registros \texttt{XMM2} y \texttt{XMM3}.

      \raisebox{2.5mm}{\texttt{XMM2:} } \begin{TAB}(b,1cm,.8cm)[5pt]{|c|c|c|c|c|c|c|c|c|}{|c|}
        0 &
        $A_2^{\mathsf{b}}$ &
        0 &
        $A_2^{\mathsf{g}}$ &
        0 &
        $A_2^{\mathsf{r}}$ &
        $\cdots$ &
        0 &
        $A_1^{\mathsf{a}}$ \\
      \end{TAB}

      \raisebox{2.5mm}{\texttt{XMM3:} } \begin{TAB}(b,1cm,.8cm)[5pt]{|c|c|c|c|c|c|c|c|c|}{|c|}
        0 &
        $B_2^{\mathsf{b}}$ &
        0 &
        $B_2^{\mathsf{g}}$ &
        0 &
        $B_2^{\mathsf{r}}$ &
        $\cdots$ &
        0 &
        $B_1^{\mathsf{a}}$ \\
      \end{TAB}


      Luego los comparamos mediante la instrucción \texttt{PCMPGTW}, almacenando la máscara resultante en \texttt{XMM2}. A continuación hacemos lo mismo con las partes altas, usando la instrucción \texttt{PUNPCKHBW} para desempaquetar y guardando el resultado en \texttt{XMM3}. Por último, la instrucción \texttt{PACKSSWB XMM2, XMM3} nos permite obtener en \texttt{XMM2} la máscara que buscábamos, ya que transforma los valores de 2 a 1 byte usando saturación.

  \subsection{Blur gaussiano}
    Este filtro recibe una imagen como entrada y devuelve como salida el resultado de aplicarle una convolución\footnote{Dadas dos funciones $f$ y $g$, una \emph{convolución} $f * g$ es una operación que las transforma en una tercera función: $(f * g)(t) = \int_{-\infty}^{+\infty} f(\tau) g(t - \tau) \,d\tau$ en el caso continuo, $(f * g)_n = \sum_{k=-\infty}^{+\infty} f_k g_{n-k}$ ($n, k \in \mathbb{Z}$) en el caso discreto.} con una función gaussiana, que dependerá de un parámetro $\sigma$ que podrá ser modificado. Dada la naturaleza del problema, trabajaremos con una convolución discreta en dos dimensiones, y como nuestro poder de cómputo es limitado, procesaremos solo una vecindad acotada de cada píxel, cuyo radio quedará determinado por un parámetro configurable $r$. En definitiva, el resultado del filtro será

    \[ O_{x,y}^k = \begin{cases}
      \displaystyle \sum_{i=-r}^r \sum_{j=-r}^r O_{x+i,y+j}^k K_{r-i,r-j}
        & \text{si } k \in \lbrace \mathsf{b, g, r} \rbrace \\
      255
        & \text{si } k = \mathsf{a}
    \end{cases} \]

    donde $K$ es la matriz o \emph{kernel} de la convolución, con

    \[ K_{i,j} = \frac{1}{2 \pi \sigma^2} e^{- \frac{(r-i)^2 + (r-j)^2}{2 \sigma^2}} \qquad \text{para todo } 0 \leq i,j \leq 2r \]

    \subsubsection{Implementación en lenguaje C}

      Para aplicar el filtro Blur, es necesario que el radio sea menor que la mitad de la cantidad de filas y menor que la mitad de la cantidad de radios. Por esto, verificamos que el radio pasado por parámetro cumpla con estas condiciones.
      
      El siguiente paso consiste en crear la matriz de convolución llamando a una función auxiliar, explicada más adelante. 

      Luego, mediante dos ciclos recorremos toda la parte de  la imagen original a la que es posible aplicarle el filtro. Esta parte es la que contempla las filas desde el valor del radio hasta $\mathtt{filas} - (\mathtt{radio} + 1$), y las columnas desde el valor del radio hasta $\mathtt{columnas} - (\mathtt{radio} + 1$). El resto de la imagen no será afectada. 

      DIBUJO

      En cada paso de esta iteración, se va a llamar a otra función que se ocupará de modificar cada píxel correctamente, utilizando la matriz de convolución creada anteriormente. 

      \paragraph{Matriz De Convolución} \mbox{} \\
        En está parte del algoritmo calculamos la matriz de convolución. Para ello, pedimos $(2 \times \mathtt{radio} + 1) \times (2 \times \mathtt{radio} + 1) \times 4$ Bytes de memoria, lugar que va a ocupar la matriz ya que su altura es $(2 \times \mathtt{radio} + 1)$ y el ancho es de $(2 \times \mathtt{radio} + 1) \times 4$ (cada píxel ocupa 4 Bytes).
        
        Utilizamos dos ciclos, ambos que van desde 0 hasta $(2 \times \mathtt{radio} + 1)$. 
        
        DIBUJO1MC

        En cada paso, calculamos la función gaussiana con el \texttt{sigma}, \texttt{radio}, \texttt{i} y \texttt{j} correspondientes donde \texttt{i} representa la fila y \texttt{j} la columna.  
        
        CUENTAMC
    
        Luego, coloca el resultado en la fila \texttt{i}, columna \texttt{j} de la matriz. Finalmente, se devuelve un puntero a la primera posición de la matriz.

      \paragraph{Afectar Pixel} \mbox{} \\
        Primero se inicializan 3 variables donde luego se van a almacenar las sumas que corresponden a cada componente del pixel a afectar (b, r y g). 

        Seguidamente, se utilizan dos ciclos para recorrer la matriz de convolución y la parte de la imágen correspondiente a los vecinos del píxel a afectar.  
        
        Estos van desde $0$ hasta $(2 \times \mathtt{radio})$, para recorrer las filas, y desde $0$ hasta $(2 \times \mathtt{radio} \times 4)$ para recorrer las columnas. En cada paso se multiplica el valor de las componentes del píxel observado por el valor de la matriz de convolución. El resultado de esta multiplicación se suma en las 3 variables creadas en el principio. 
        
        Finalmente, se copia el valor de cada variable en cada componente del píxel en la imagen destino. Luego, en la componente “transparencia” se coloca el valor 255.  

    \subsubsection{Implementación en lenguaje ensamblador} 
      Este algoritmo se ocupa de recorrer toda la porción de la imagen a la que es posible aplicarle el filtro. 
      
      Al igual que en la implementación en C, hace una comparación para revisar si el radio es válido. 
      
      Luego, utilizando la instrucción CALL, hace un llamado a la función matrizDeConvolución (implementada en C) la cual le devuelve un puntero a la matriz de convolución creada. 
      
      Posteriormente, se utilizan dos ciclos para recorrer la porción de la imágen. Estos utilizan los registros r8 para recorrer las columnas y r9 para recorrer las filas.
  
      DIBUJO1BLURASM
      
      En cada paso del ciclo, utilizando nuevamente la instrucción CALL, se realiza un llamado a la función afectarPixel (implementada en assembler) que se ocupa de modificar el píxel correspondiente. 

      \paragraph{Afectar Pixel}\mbox{} \\
        El primer paso de este algoritmo es encontrar el puntero al píxel que se debe afectar en la imagen original y otro puntero al mismo píxel pero en la imagen destino. Estos punteros son guardados en los registros r12 y r14 respectivamente.   

        Llamaremos submatriz imagen a la porción de la imagen original que se debe utilizar para que junto con la matriz de convolución se obtenga el nuevo valor del píxel. Esta submatriz es la que contiene al píxel a modificar en el centro y su tamaño es el mismo de la matriz de convolución. 
        
        DIBUJO1AFECTARPIXELASM

        Luego, se debe encontrar el puntero al primer píxel de la submatriz imagen. Esto se calcula de la siguiente manera: $r12 - 4 \times (\mathtt{radio} - \mathtt{radio} \times \mathtt{columnas})$. Este puntero se encuentra en el registro r13 y es utilizado para recorrer la submatriz. 

        En el registro r11 se guarda la cantidad total de píxeles que componen la submatriz imagen. 

              $R11 = (2 \times \mathtt{radio} + 1)^{2}$  
        
        El registro r15 contiene el tamaño de las filas.
        
              $R15 =(2 \times \mathtt{radio}  + 1)$.

        Estos últimos dos se utilizan como registros contadores.

        A continuación, se recorren por filas la submatriz imagen y la matriz de convolución a la vez. R11 se utiliza para saber cuando finalizar el bucle, es decir, cuando ya se observaron todos los píxeles. Estos son procesados utilizando instrucciones SSE y registros del tipo \texttt{XMM}. En cada uno de estos registros es posible guardar 4 píxeles, ya que cada píxel ocupa 4 bytes. 

        DIBUJO2AFECTARPIXELASM
  
        En cada paso de este ciclo se considera una fila, utilizando r15 para saber cuando termina. Se toman 4 píxeles de la submatriz imagen y los correspondientes 4 de la matriz de convolución. Luego de desempaquetar los píxeles se realiza la multiplicación de cada componente (r, b o g) con el valor de la matriz de convolución que le pertenece. El resultado de cada producto se suma al registro \texttt{XMM6}. 

        DIBUJO3AFECTARPIXELASM  

        Se puede notar que el tamaño de las filas es congruente a 1 o 3 módulo 4. 
        CUENTA1. Por lo tanto, se procesan de a 4 píxeles hasta llegar a alguno de los dos casos borde posibles: cuando queda 1 píxel por computar o cuando quedan 3. 
        
        La solución a este problema es tomar y desempaquetar los píxeles de la submatriz imagen que todavía no fueron procesados junto con sus siguientes, hasta completar 4. Esto es así en todos los casos, excepto en el que los píxeles restantes son los últimos de la submatriz imágen (es decir, los que se corresponden con la última fila). En este caso, se toman los píxeles anteriores, ya que de otra forma, si el píxel a modificar se encuentra en alguna de las 3 últimas posiciones se accedería a posiciones de memoria fuera de la imagen. Estos píxeles no se tienen en cuenta a la hora de realizar el cálculo. 
          
        Esto mismo se realiza para la matriz de convolución.
          
        DIBUJO4AFECTARPIXELASM

        Al finalizar el ciclo, se tiene en \texttt{XMM6} el valor esperado para cada componente (r, b y g) del píxel a afectar en floats. Primero lo pasamos a integers y despues en la componente “transparencia” se coloca un 255, y se empaqueta \texttt{XMM6} para luego copiarlo en la posición del píxel que se quiere modificar en la imagen destino. 